<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Mind</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        <link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
    </head>
    <body class="vscode-light">
        <h2 id="mind">Mind</h2>
<hr>
<ol>
<li><code>typescript</code> 学习
<ul>
<li><code>typescript</code> 的变量类型</li>
<li><code>typescript</code> 中的类</li>
<li><code>typescript</code> 中的接口</li>
<li><code>typescript</code> 中的泛型</li>
<li><code>typescript</code> 命名空间</li>
<li><code>typescript</code> 装饰器</li>
</ul>
</li>
<li><code>axios</code> 巩固<br>
如：
<ul>
<li>并发多个请求 <code>axios.all() </code></li>
<li>创建实例 <code>axios.create()</code></li>
<li>拦截器 <code>axios.interceptors.request.use(fn, fn)</code> 和 <code>axios.interceptors.response.use(fn, fn)</code></li>
<li>取消请求 <code>axios.CancelToken</code><br>
<a href="https://www.npmjs.com/package/axios">axios 文档</a></li>
</ul>
</li>
<li><code>vuex</code> 巩固
<ul>
<li><code>state</code></li>
<li><code>mutation</code> (<code>commit</code> 触发)</li>
<li><code>action</code> (<code>dispatch</code> 触发)</li>
<li><code>getter</code></li>
<li><code>module</code></li>
<li>辅助函数 如：<code>mapState</code> 等</li>
</ul>
</li>
<li><code>better-scroll</code> 创建滚动视图<br>
<a href="http://ustbhuangyi.github.io/better-scroll/doc/zh-hans/">BetterScroll 1.x 文档</a><br>
<a href="https://better-scroll.github.io/docs/zh-CN/">BetterScroll 2.x 文档</a></li>
<li><code>swiper</code> 插件创建轮播图<br>
<a href="https://www.swiper.com.cn/">swiper 文档</a></li>
<li><code>HTML</code> 和 <code>CSS</code> 复习
<ul>
<li>溢出省略号</li>
<li><code>display</code> 的值</li>
<li>元素水平垂直居中的多种实现方法</li>
<li>命名锚点</li>
<li>五大内核</li>
<li><code>HTML5</code> 新增内容</li>
<li><code>CSS3</code> 新增内容</li>
<li>媒体查询和响应式</li>
<li><code>DPR</code> 以及 <code>em</code>、<code>rem</code>、 <code>vw</code>、<code>vh</code></li>
<li>布局
<ul>
<li><code>Div+CSS</code> 布局</li>
<li><code>Float</code> 布局</li>
<li><code>flex</code> 布局</li>
<li><code>column</code> 布局</li>
<li><code>Grid</code> 布局</li>
<li>弹性布局</li>
<li>等比缩放布局（<code>rem</code> 布局）</li>
<li><code>VH</code>、<code>VW</code><br>
......</li>
</ul>
</li>
</ul>
</li>
<li><code>js</code> 中事件的巩固
<ul>
<li>事件流<br>
<code>IE</code> 事件流和 <code>DOM</code> 标准事件流的区别</li>
<li>事件冒泡和事件捕获</li>
<li>事件委托</li>
<li>事件监听<br>
同一元素要绑定多个同一事件，可以用事件监听 <code>addEventListener()</code></li>
</ul>
</li>
<li><code>vue</code> 中插槽 <code>slot</code> 的使用
<ul>
<li>后备内容（即默认值）</li>
<li>具名插槽</li>
<li>作用域插槽（可利用插槽传值）</li>
<li>解构插槽</li>
<li>缩写 <code>#</code></li>
</ul>
</li>
<li><code>css</code> 自定义属性（<code>css</code> 变量）
<ul>
<li>一般写在 <code>:root</code> 中</li>
<li>属性前面带 <code>--</code> 的就是变量</li>
<li>用 <code>var()</code> 使用变量，把变量放到括号内</li>
</ul>
</li>
<li><code>js</code> 复习 <code>1</code>
<ul>
<li><code>ECMAScript</code>
<ul>
<li>数据类型 基本<code>number</code> <code>string</code> <code>boolean</code> <code>null</code> <code>undefined</code> <code>symbol(es6)</code> 引用<code>object</code></li>
<li>运算符 <code>()</code> <code>单目运算</code> <code>算术运算</code> <code>关系运算</code> <code>逻辑运算</code> <code>三目运算</code> <code>赋值运算</code></li>
<li>条件语句 <code>if</code> <code>switch</code></li>
<li>循环语句 <code>while</code> <code>do while</code> <code>for</code></li>
<li>作用域，作用域链</li>
<li>变量提升</li>
<li>事件绑定</li>
<li>数组，数组方法（以及 <code>ES5</code> 新增数组方法）</li>
<li>堆和栈</li>
<li>冒泡排序，选择排序</li>
<li>字符串方法</li>
<li>正则</li>
<li><code>ES6</code> 新增内容
<ol>
<li><code>let</code> <code>const</code></li>
<li><code>解构赋值</code></li>
<li><code>字符串模板</code></li>
<li><code>扩展运算符</code></li>
<li><code>Set</code> <code>Map</code></li>
<li><code>箭头函数</code></li>
<li><code>Promise</code></li>
<li><code>class</code></li>
<li><code>数组方法（如 find()、findIndex()、includes() ....）</code></li>
<li><code>字符串方法（如 startsWith()、endsWith() ....）</code><br>
.......</li>
</ol>
</li>
<li><code>this</code> 的理解</li>
</ul>
</li>
<li><code>BOM</code>
<ul>
<li><code>window</code> 对象
<ul>
<li><code>document</code></li>
<li><code>history</code></li>
<li><code>location</code></li>
<li><code>screen</code></li>
<li><code>navigator</code></li>
<li>定时器 <code>setInterval</code> <code>setTimeout</code></li>
<li><code>open()</code><br>
......</li>
</ul>
</li>
</ul>
</li>
<li><code>DOM</code>
<ul>
<li>元素节点
<ul>
<li>父子节点 <code>parentNode</code> <code>childNodes</code> <code>children</code> <code>firstChild</code> <code>lastChild</code> <code>firstElementChild</code> <code>lastElementChild</code></li>
<li>兄弟节点 <code>nextSibling</code> <code>previousSibling</code> <code>nextElementSibling</code> <code>previousElementSibling</code></li>
</ul>
</li>
<li>属性节点
<ul>
<li><code>attributes</code></li>
</ul>
</li>
<li>文本节点</li>
<li>注释节点</li>
<li><code>createElement()</code> <code>createTextNode()</code></li>
<li><code>appendChild()</code> <code>insertBefore()</code></li>
<li><code>replaceChild()</code> <code>cloneChild()</code></li>
<li><code>removeChild()</code> <code>renove()</code></li>
<li>事件对象 <code>pageX</code>, <code>pageY</code>, <code>clientX</code>, <code>clientY</code>, <code>offsetX</code>, <code>offsetY</code> ......</li>
<li>事件监听 <code>addEventListener()</code></li>
<li>事件委托</li>
<li>事件流 （<code>ie</code> 事件流和 <code>DOM</code> 标准事件流的区别）</li>
<li><code>scroll</code> 家族</li>
<li><code>offset</code> 家族<br>
........</li>
</ul>
</li>
</ul>
</li>
<li><code>js</code> 复习 <code>2</code>
<ul>
<li><code>http</code> 和 <code>https</code></li>
<li><code>url</code> 分解</li>
<li><code>DNS</code></li>
<li><code>php</code> 了解巩固，<code>mySQL</code> 了解巩固
<ul>
<li><code>php声明变量，输出echo print ....， 数据类型，字符串，数组 ....</code></li>
<li><code>create database</code>, <code>drop database</code>, <code>use 数据库</code></li>
<li><code>create table 表名(...)</code></li>
<li><code>insert into user set ...</code></li>
<li><code>delete from user where ...</code></li>
<li><code>update user set ...</code></li>
<li><code>select * from user where ...</code></li>
</ul>
</li>
<li>本地存储 <code>cookie</code>, <code>localStorage</code>, <code>sessionStorage</code></li>
<li><code>JSON</code> 和 <code>XML</code>, 区别</li>
<li><code>AJAX</code> <code>XMLHttpRequest()</code> 封装 <code>AJAX</code> 请求</li>
<li><code>get</code> 和 <code>post</code> 请求的区别</li>
<li><code>AJAX</code> 跨域，几种主流的解决跨域的方法
<ul>
<li>开发中，前后端分离，一般设置代理 <code>proxy</code> 代理到服务主机，生产环境中基本不会出现问题，因为前后端代码在一个环境下了</li>
<li>若请求其他网站上的资源，可以：
<ul>
<li>服务端语言代理请求</li>
<li><code>jsonp</code> 跨域</li>
<li><code>CORS</code> 跨域资源共享</li>
<li><code>nginx</code> 代理跨域</li>
</ul>
</li>
</ul>
</li>
<li><code>Promise (ES6)</code>
<ul>
<li><code>resolve()</code></li>
<li><code>reject()</code></li>
<li><code>then()</code></li>
<li><code>catch()</code></li>
<li><code>Promise.all()</code></li>
</ul>
</li>
<li>闭包，闭包的作用</li>
<li>垃圾回收机制
<ul>
<li>标记清除</li>
<li>引用计数</li>
</ul>
</li>
<li>作用域，作用域链</li>
<li>原型，原型链
<ul>
<li><code>protptype</code></li>
<li><code>_ _proto_ _</code></li>
<li><code>constructor</code></li>
</ul>
</li>
<li>继承
<ul>
<li><code>ES5</code> 实现继承
<ol>
<li>构造函数继承（对象冒充继承）（调用父类构造函数，改变 <code>this</code> 指向）</li>
<li>原型链继承（改变子类的原型指向）</li>
<li>混合继承（以上2种的结合）</li>
<li>拷贝继承（比如普通对象，利用拷贝，给需要继承的子对象）（浅拷贝）</li>
<li>也可以用 <code>Object.setPrototypeOf()</code> 来设置对象的原型来实现继承</li>
</ol>
</li>
<li><code>ES6</code> 实现继承
<ul>
<li><code>Class</code> 类， <code>extends</code> 实现继承， <code>super()</code> 获得父类实例</li>
</ul>
</li>
</ul>
</li>
<li><code>Object</code> 的方法  ..........</li>
<li><code>jQuery</code>
<ul>
<li>选择器</li>
<li><code>jQuery DOM</code>
<ul>
<li>节点操作</li>
<li>常用方法</li>
</ul>
</li>
<li><code>jQuery</code> 动画
<ul>
<li><code>slideUp()</code>, <code>slideDown()</code></li>
<li><code>toggle()</code></li>
<li><code>show()</code>, <code>hide()</code></li>
<li><code>fadeIn()</code>, <code>fadeOut()</code></li>
<li>自定义动画 <code>animate()</code></li>
</ul>
</li>
<li><code>jQuery</code> 事件
<ul>
<li><code>bind()</code>, <code>unbind()</code></li>
<li><code>on()</code>, <code>off()</code></li>
<li><code>one()</code></li>
<li><code>hover()</code></li>
<li><code>toggle()</code></li>
</ul>
</li>
<li><code>jQuery</code> 事件对象</li>
<li><code>jQuery</code> 扩展
<ul>
<li><code>$.extend()</code></li>
<li><code>$.fn.extend()</code></li>
</ul>
</li>
</ul>
</li>
<li>设计模式
<ul>
<li>工厂模式</li>
<li>单例模式</li>
<li>代理模式</li>
<li>策略模式</li>
<li>观察者模式（发布-订阅模式）<br>
..........</li>
</ul>
</li>
<li><code>ES6 Module</code>
<ul>
<li>模块化
<ul>
<li><code>commonJS</code> 规范，如 <code>node.js</code> 用于服务器，同步， <code>module.export</code>, <code>require</code></li>
<li><code>AMD</code> 规范，如 <code>requireJS</code> 用于浏览器，异步， <code>define</code>, <code>require</code></li>
<li><code>CMD</code> 规范，如 <code>seaJS</code> 用于浏览器，异步</li>
<li><code>ES6 Module</code> 用于服务端和浏览器， <code>export</code>, <code>export default</code>, <code>import...from...</code>, <code>as</code></li>
</ul>
</li>
<li><code>ES6 Module</code> 和 <code>commonJS</code> 区别
<ul>
<li><code>commonJS</code> 是值的拷贝，<code>ES6 Module</code> 是值的引用<br>
..........</li>
</ul>
</li>
</ul>
</li>
<li>脚本的 <code>defer</code> 和 <code>async</code>
<ul>
<li><code>defer</code> 渲染完再执行</li>
<li><code>async</code> 下载完就执行</li>
</ul>
</li>
<li><code>Node.js</code>
<ul>
<li>特征
<ul>
<li>单线程</li>
<li>非阻塞 <code>I/O</code></li>
<li>事件驱动，事件循环机制</li>
</ul>
</li>
<li>搭建 <code>web</code> 服务器
<ul>
<li><code>http</code> 模块</li>
<li>读写文件，<code>fs</code> 模块，<code>readFile()</code>, <code>writeFile()</code>, <code>appendFile()</code></li>
<li><code>path</code> 模块</li>
<li><code>url</code> 模块<br>
.............</li>
</ul>
</li>
</ul>
</li>
<li><code>Git</code> 和 <code>SVN</code>
<ul>
<li><code>SVN</code></li>
<li><code>Git</code> (各种指令)</li>
</ul>
</li>
<li><code>Gulp</code>, 前端自动化构建工具
<ul>
<li><code>gulp.task()</code></li>
<li><code>gulp.src()</code></li>
<li><code>pipe()</code></li>
<li><code>gulp.dest()</code></li>
<li><code>gulp.watch()</code></li>
</ul>
</li>
<li><code>SASS</code>
<ul>
<li>变量 <code>$</code></li>
<li>嵌套</li>
<li><code>@import</code></li>
<li><code>@mixin</code>, <code>@include</code></li>
<li><code>@extend</code></li>
<li><code>@if</code>, <code>@for</code>, <code>@function</code></li>
</ul>
</li>
<li><code>requireJS</code>
<ul>
<li><code>requirejs.config</code></li>
<li><code>require()</code></li>
<li><code>define()</code></li>
</ul>
</li>
</ul>
</li>
<li>服务器等相关知识巩固
<ul>
<li>公众号二次开发，部署到腾讯云服务器</li>
<li><code>nginx</code> 知识巩固理解，正向代理，反向代理等</li>
</ul>
</li>
<li><code>Node.js</code>
<ul>
<li>模块化开发</li>
<li>文件操作 <code>fs</code></li>
<li>地址的操作 <code>url</code></li>
<li>请求参数的操作 <code>querystring</code></li>
<li>发送请求 <code>http</code><br>
..........</li>
</ul>
</li>
<li>正向代理和反向代理
<ul>
<li>正向代理架设再客户机和目标主机之间，反向代理假设在服务器端</li>
<li>正向代理代理客户端，反向代理代理服务端</li>
</ul>
</li>
<li><code>express</code> 的使用
<ul>
<li><code>express</code> 搭建服务</li>
<li><code>express</code> 处理静态资源， <code>express.static()</code></li>
<li>处理请求参数 <code>body-parser</code></li>
<li>中间件</li>
<li>路由的使用 <code>new express.Router()</code><br>
..........</li>
</ul>
</li>
<li>前后端分离与不分离</li>
<li><code>mongodb</code>
<ul>
<li><code>mongoose</code></li>
<li><code>save()</code></li>
<li><code>deleteOne()</code> ......</li>
<li><code>updateOne()</code> ......</li>
<li><code>find()</code> ......<br>
.........</li>
</ul>
</li>
<li><code>session</code>
<ul>
<li>用于服务端，加密，储存用户信息  ...........</li>
<li><code>Session</code> 是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中</li>
<li><code>Cookie</code> 是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现 <code>Session</code> 的一种方式
<a href="https://www.npmjs.com/package/connect-mongodb-session">connect-mongodb-session</a></li>
</ul>
</li>
<li><code>mockjs</code>
<ul>
<li>可以用来 <code>mock</code> 假数据 ..........<br>
<a href="http://mockjs.com/">Mock.js</a></li>
</ul>
</li>
<li><code>Vue</code> 框架
<ul>
<li><code>vue</code> 指令</li>
<li><code>computed</code>, <code>watch</code></li>
<li>生命周期</li>
<li>组件声明（全局，局部）</li>
<li>组件调用</li>
<li>父子组件传值</li>
<li>组件缓存 <code>keep-alive</code>, 动态组件 <code>component :is</code></li>
<li><code>slot</code>, <code>v-slot</code>, 传值 .....</li>
<li>非父子组件传值 <code>$emit</code> <code>$on</code></li>
<li>自定义指令 <code>Vue.directive()</code></li>
<li>组件上用 <code>v-model</code></li>
<li><code>vm.$children</code>, <code>vm.$parent(</code>)</li>
<li><code>Vue.use()</code> 使用插件</li>
<li>过滤器 <code>Vue.filter()</code></li>
<li><code>vue</code> 路由
<ul>
<li>动态路由，路由传值 ........</li>
<li>编程式导航， 也可以传值 ........</li>
<li>重定向</li>
<li>组件懒加载</li>
<li>路由 <code>props</code> 传值<br>
.............</li>
</ul>
</li>
<li><code>vue</code> 动画 <code>transition</code></li>
<li><code>vuex</code>
<ul>
<li><code>state</code></li>
<li><code>getters</code></li>
<li><code>mutations</code></li>
<li><code>actions</code></li>
<li><code>modules</code></li>
<li>命名空间 <code>namespaced</code></li>
<li>辅助函数<br>
..........</li>
</ul>
</li>
<li>路由守卫
<ul>
<li><code>router.beforeEach((to,from,next)=&gt;{})</code></li>
<li><code>router.beforeResolve((to,from,next)=&gt;{})</code></li>
<li><code>router.afterEach((to,from)=&gt;{})</code></li>
<li><code>beforeEnter((to,from,next)=&gt;{})</code></li>
<li><code>beforeRouteEnter((to,from,next)=&gt;{})</code></li>
<li><code>beforeRouteLeave((to,from,next)=&gt;{})</code></li>
<li><code>beforeRouteUpdate((to,from,next)=&gt;{})</code><br>
.........</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="%e5%85%b6%e4%bb%96%e7%9f%a5%e8%af%86%e7%82%b9">其他知识点</h4>
<blockquote>
<p><code>web Worker</code>: <code>new Worker('...')</code>,起 <code>js</code> 线程到后台运行<br>
<code>postMessage()</code> 发送消息，<code>terminate()</code> 方法结束进程，通过 <code>onmessage</code> 方法接受数据 等 .....<br>
<a href="https://www.w3school.com.cn/html5/html_5_webworkers.asp">HTML 5 Web Workers</a></p>
</blockquote>
<blockquote>
<p><code>new Blob()</code>
binary large object 二进制大对象<br>
<a href="https://www.jianshu.com/p/33564726aed8">浅谈JavaScript中的Blob对象</a></p>
</blockquote>
<blockquote>
<p><code>window.URL.createObjectURL()</code><br>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURL">URL.createObjectURL()</a><br>
<a href="https://blog.csdn.net/cpongo5/article/details/88577883">前端接受后端文件流并下载的几种方法var blob = new Blob([content]); URL.createObjectURL(blob);</a></p>
</blockquote>
<blockquote>
<p><code>a</code> 标签的 <code>download</code> 属性<br>
如： <code>&lt;a id=&quot;id&quot; download=&quot;a.txt&quot;&gt;点我&lt;/a&gt;</code><br>
<a href="https://www.w3school.com.cn/tags/att_a_download.asp">HTML <a> download 属性</a></p>
</blockquote>
<blockquote>
<p><code>nginx</code> 的 <code>location</code> 配置，指定静态资源， <code>alias</code> 和 <code>root</code> 的用法</p>
</blockquote>
<blockquote>
<p><code>websocket</code>, <code>socket.io</code><br>
<a href="https://www.runoob.com/html/html5-websocket.html">HTML5 WebSocket</a><br>
<a href="https://www.w3cschool.cn/socket/">socket.io官方文档</a></p>
</blockquote>
<blockquote>
<p><code>jsdom</code> 插件，可以用其获取本地或网页上脚本内的数据<br>
<a href="https://www.npmjs.com/package/jsdom">jsdom 的讲解</a></p>
</blockquote>
<blockquote>
<p><code>Vue</code> 的混入用法, 可以将一些公共的功能给拎出来，用混入的方法给组件扩展功能
分全局混入 <code>Vue.mixin()</code> 和局部混入 <code>mixins:[]</code><br>
<a href="https://cn.vuejs.org/v2/guide/mixins.html">Vue 混入 mixin</a></p>
</blockquote>
<blockquote>
<p>单页面应用 <code>SPA</code> 和多页面应用 <code>MPA</code><br>
单页面应用页面跳转快，用户体验流畅，但首屏加载相对较慢，<code>SEO</code> 差；<br>
多页面应用页面切换相对较慢，但首屏加载快，也利于 <code>SEO</code> 。<br>
<a href="http://www.zhiliaotang.net/jishujiaoliu/web/965.html">一张图告诉你单页面开发和多页面开发的区别</a></p>
</blockquote>
<blockquote>
<p>项目打包给手机端做成 <code>APP</code>，需要注意：</p>
<ol>
<li>前端路由要改为 <code>hash</code> 模式</li>
<li>项目的打包根路径要改为 <code>'/'</code> , 即 <code>vue.config.js</code> 中配置 <code>publicPath</code> 为 <code>'./'</code></li>
<li>根页面中，引入的静态资源全部用 <code>&lt;%= BASE_URL %&gt;</code></li>
<li>把打包的文件给了手机端，但是服务还是在服务器上的，数据还是通过服务器来，通过请求里面的 <code>baseURL</code> 有配置，那就需要服务端设置允许跨域了，这样才能通。</li>
</ol>
</blockquote>
<blockquote>
<p>做成 <code>APP</code> 也可以让手机端去调服务上的项目地址，不过打开速度较慢，因为这样项目还是部署在服务器上的，所以，根路径还是绝对路径的，路由 <code>history</code> 也没有问题</p>
</blockquote>
<blockquote>
<p>项目打包给后端，注意事项：</p>
<ol>
<li>前端路由配置为 <code>history</code> 模式时，要做好刷新时的后端配置</li>
<li>让后端配置好各资源请求的路径</li>
<li><code>publicPath</code> 默认是 <code>'/'</code></li>
</ol>
</blockquote>
<blockquote>
<p><code>hash</code> 模式和 <code>history</code> 模式<br>
<a href="https://www.jb51.net/article/144341.htm">Vue-router 中hash模式和history模式的区别</a></p>
</blockquote>
<blockquote>
<p><code>XSS</code> 和 <code>CSRF</code><br>
<code>XSS</code> : <code>Cross Site Scripting</code> , 跨站脚本攻击<br>
预防： 输入过滤、输出转义 等..........<br>
<code>CSRF</code> : <code>Cross Site Request Forgery</code> , 跨站请求伪造<br>
预防： 验证 <code>HTTP Referer</code> 字段、请求地址添加 <code>token</code> 并验证 等.........<br>
<a href="https://www.jianshu.com/p/64a413ada155">XSS和 CSRF攻击详解</a></p>
</blockquote>
<blockquote>
<p><code>webpack</code><br>
<code>mode</code><br>
<code>entry</code><br>
<code>output</code><br>
<code>module</code><br>
<code>loader</code><br>
<code>plugin</code><br>
<code>devServer</code><br>
<a href="https://www.webpackjs.com/concepts/">webpack 中文文档</a></p>
</blockquote>

    </body>
    </html>